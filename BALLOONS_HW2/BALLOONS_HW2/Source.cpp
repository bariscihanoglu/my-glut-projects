/*********
   CTIS164 - Template Source Program
----------
STUDENT : Baris Cihanoglu
SECTION : 2
HOMEWORK: 2
----------
PROBLEMS:
----------
ADDITIONAL FEATURES:

Balloon colors are random. There are 5 balloons and they change colors upon respawning.

There is a max score. If player gets a higher then the max score,
at the end screen, program shows "New high score" and changes the max score.

Background color changes according to the score.

*********/

#ifdef _MSC_VER
#define _CRT_SECURE_NO_WARNINGS
#endif
#include <GL/glut.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <stdarg.h>
#include <time.h>

#define WINDOW_WIDTH  1200
#define WINDOW_HEIGHT 800

#define RED    0
#define PURPLE 1
#define BLUE   2
#define YELLOW 3
#define ORANGE 4

#define STATE_RUN    0
#define STATE_STOP   1
#define STATE_END    2

#define TIMER_PERIOD     30 // Period for the timer.
#define TIMER_ON         1  // 0:disable timer, 1:enable timer

#define D2R 0.0174532

// balloon type
typedef struct {
    int x;
    int y;
    bool hit;
    int color;
} balloon_t;

// bullet type
typedef struct {
    int x;
    int y;
    bool shoot;
} bullet_t;

//all balloons spawned at y = -430. Their x is randomly generated by Init function.
balloon_t balloons[5] = { { 0, -430, 0, 0 }, { 0, -430, 0, 0 }, { 0, -430, 0, 0 }, { 0, -430, 0, 0 }, { 0, -430, 0, 0 } };
bullet_t bullet = { 0, 700, 0 };

/* Global Variables for Template File */
bool up = false, down = false, right = false, left = false, F1 = false, scoreChange = false, newMax = false;
int  winWidth, winHeight, color, milisec = 20000, gameState = STATE_RUN, balloonCounter = 0, gunY = 0, score = 0, maxScore = 0;

//
// to draw circle, center at (x,y)
// radius r
//
void circle(int x, int y, int r)
{
#define PI 3.1415
    float angle;
    glBegin(GL_POLYGON);
    for (int i = 0; i < 100; i++)
    {
        angle = 2 * PI * i / 100;
        glVertex2f(x + r * cos(angle), y + r * sin(angle));
    }
    glEnd();
}

void circle_wire(int x, int y, int r)
{
#define PI 3.1415
    float angle;

    glBegin(GL_LINE_LOOP);
    for (int i = 0; i < 100; i++)
    {
        angle = 2 * PI * i / 100;
        glVertex2f(x + r * cos(angle), y + r * sin(angle));
    }
    glEnd();
}

void print(int x, int y, const char* string, void* font)
{
    int len, i;

    glRasterPos2f(x, y);
    len = (int)strlen(string);
    for (i = 0; i < len; i++)
    {
        glutBitmapCharacter(font, string[i]);
    }
}

// display text with variables.
// vprint(-winWidth / 2 + 10, winHeight / 2 - 20, GLUT_BITMAP_8_BY_13, "ERROR: %d", numClicks);
void vprint(int x, int y, void* font, const char* string, ...)
{
    va_list ap;
    va_start(ap, string);
    char str[1024];
    vsprintf_s(str, string, ap);
    va_end(ap);

    int len, i;
    glRasterPos2f(x, y);
    len = (int)strlen(str);
    for (i = 0; i < len; i++)
    {
        glutBitmapCharacter(font, str[i]);
    }
}

// vprint2(-50, 0, 0.35, "00:%02d", timeCounter);
void vprint2(int x, int y, float size, const char* string, ...) {
    va_list ap;
    va_start(ap, string);
    char str[1024];
    vsprintf_s(str, string, ap);
    va_end(ap);
    glPushMatrix();
    glTranslatef(x, y, 0);
    glScalef(size, size, 1);

    int len, i;
    len = (int)strlen(str);
    for (i = 0; i < len; i++)
    {
        glutStrokeCharacter(GLUT_STROKE_ROMAN, str[i]);
    }
    glPopMatrix();
}

// displays sky
void displayBackground(void)
{
    if (score < 5)
    {
        glClear(GL_COLOR_BUFFER_BIT);
        glBegin(GL_QUADS);
        glColor3f(0.400f, 0.72f, 0.011f);
        glVertex2f(500, -400);
        glVertex2f(-500, -400);

        glColor3f(1, 1, 1);
        glVertex2f(-500, 400);
        glVertex2f(500, 400);
        glEnd();

    }
    else if (score >= 5 && score < 10)
    {
        glBegin(GL_QUADS);
        glColor3f(0.529f, 0.808f, 0.922f);
        glVertex2f(500, -400);
        glVertex2f(-500, -400);

        glColor3f(1, 1, 1);
        glVertex2f(-500, 400);
        glVertex2f(500, 400);
        glEnd();
    }
    else if (score >= 10 && score < 12)
    {
        glBegin(GL_QUADS);
        glColor3f(0.124f, 0.0f, 0.922f);
        glVertex2f(500, -400);
        glVertex2f(-500, -400);

        glColor3f(1, 1, 1);
        glVertex2f(-500, 400);
        glVertex2f(500, 400);
        glEnd();
    }
    else if (score >= 12)
    {
        glBegin(GL_QUADS);
        glColor3f(0.0f, 0.922f, 0.472f);
        glVertex2f(500, -400);
        glVertex2f(-500, -400);

        glColor3f(1, 1, 1);
        glVertex2f(-500, 400);
        glVertex2f(500, 400);
        glEnd();
    }
}

// displays upper and right-hand panels.
void displayPanels(void)
{
    glColor3f(0, 0, 0);
    glRectf(-1000, -1000, 1000, -400);
    glRectf(-1000, -1000, -500, 1000);
    glRectf(1000, 1000, -1000, 400);
    glRectf(1000, 1000, 500, -1000);
    glColor3f(0, 0, 0);
    glRectf(360, -400, 500, 400);
    glRectf(-500, -400, 500, -360);

    glColor3f(0.9, 0.9, 0.9);
    vprint(400, 340, GLUT_BITMAP_HELVETICA_18, "TIMER");
    vprint2(370, 300, 0.35, "%02d:%02d", milisec / 1000, milisec % 1000 / 10);
    vprint(395, 240, GLUT_BITMAP_HELVETICA_18, "SCORE");
    vprint2(388, 200, 0.35, "%003d", score);
    vprint(375, 140, GLUT_BITMAP_HELVETICA_18, "MAX SCORE");
    vprint2(388, 100, 0.35, "%003d", maxScore);
    vprint(365, -340, GLUT_BITMAP_8_BY_13, "Baris Cihanoglu");
    vprint(363, -353, GLUT_BITMAP_8_BY_13, "22202987");
    if (gameState == STATE_RUN)
    {
        glColor3f(1, 1, 0);
        vprint(-250, -385, GLUT_BITMAP_HELVETICA_18, "<Up-Down> to aim / <Space> to shoot / <F1> to pause");
    }
    else if (gameState == STATE_STOP)
    {
        glColor3f(0, 0, 0);
        vprint2(-150, 0, 0.35, "PAUSED", score);
        glColor3f(1, 1, 0);
        vprint(-150, -385, GLUT_BITMAP_HELVETICA_18, "Press <F1> to resume");
    }
    else
    {
        glColor3f(0, 0, 0);
        vprint2(-200, 0, 0.35, "GAME END", score);
        glColor3f(1, 0, 0);
        if (newMax)
            vprint2(-280, -50, 0.35, "NEW MAX SCORE!!!", score);
        glColor3f(1, 1, 0);
        vprint(-180, -385, GLUT_BITMAP_HELVETICA_18, "Press <F1> to restart");
    }
}

// diplays a balloon
void displayBalloon(int x, int y, int color)
{
    switch (color)
    {
    case RED:
        glColor3f(255 / 256., 30 / 256., 22 / 256.);
        break;
    case PURPLE:
        glColor3f(191 / 256., 39 / 256., 247 / 256.);
        break;
    case BLUE:
        glColor3f(61 / 256., 222 / 256., 255 / 256.);
        break;
    case YELLOW:
        glColor3f(239 / 256., 242 / 256., 70 / 256.);
        break;
    case ORANGE:
        glColor3f(255 / 256., 165 / 256., 10 / 256.);
        break;
    }
    circle(x, y, 30);
    glBegin(GL_POLYGON);
    glVertex2f(x, y - 28);
    glVertex2f(x + 5, y - 35);
    glVertex2f(x - 5, y - 35);
    glEnd();
    glLineWidth(0.2);
    glColor3f(0, 0, 0);
    circle_wire(x, y, 30);
    glColor3f(1, 1, 1);
    circle(x + 14, y - 16, 4);
    glBegin(GL_LINES);
    glVertex2f(x, y - 35);
    glVertex2f(x, y - 45);
    glEnd();
}

// displays the gun
void displayGun(int y)
{
    glColor3f(45 / 256., 90 / 256., 94 / 256.);
    glRectf(-500, y - 12, -450, y + 12);
    glBegin(GL_POLYGON);
    glVertex2f(-450, y + 12);
    glVertex2f(-440, y + 8);
    glVertex2f(-440, y - 8);
    glVertex2f(-450, y - 12);
    glEnd();
    glColor3f(24 / 256., 55 / 256., 23 / 256.);
    glBegin(GL_LINES);
    glVertex2f(-450, y + 12);
    glVertex2f(-450, y - 12);
    glEnd();
    glColor3f(53 / 256., 81 / 256., 84 / 256.);
    glBegin(GL_POLYGON);
    glVertex2f(-500, y + 22);
    glVertex2f(-460, y + 12);
    glVertex2f(-500, y + 12);
    glEnd();
    glBegin(GL_POLYGON);
    glVertex2f(-500, y - 22);
    glVertex2f(-460, y - 12);
    glVertex2f(-500, y - 12);
    glEnd();
}

// displays the bullet
void displayBullet(int x, int y)
{
    glColor3f(232 / 255., 197 / 255., 2 / 255.);
    glBegin(GL_POLYGON);
    glVertex2f(x, y);
    glVertex2f(x - 8, y + 8);
    glVertex2f(x - 24, y + 8);
    glVertex2f(x - 24, y - 8);
    glVertex2f(x - 8, y - 8);
    glEnd();
    glRectf(x - 24, y + 6, x - 28, y - 6);
    glRectf(x - 28, y + 8, x - 32, y - 8);
    glColor3f(186 / 255., 158 / 255., 0 / 255.);
    glBegin(GL_LINES);
    glVertex2f(x - 8, y + 8);
    glVertex2f(x - 8, y - 8);
    glEnd();
    glBegin(GL_LINES);
    glVertex2f(x - 24, y + 8);
    glVertex2f(x - 24, y - 8);
    glEnd();
    glBegin(GL_LINES);
    glVertex2f(x - 28, y + 8);
    glVertex2f(x - 28, y - 8);
    glEnd();
}

//
// To display onto window using OpenGL commands
//
void display() {
    //
    // clear window to black
    //
    glClearColor(0, 0, 0, 0);
    glClear(GL_COLOR_BUFFER_BIT);

    srand(time(NULL));

    displayBackground();

    //if not hit, spawns balloons at specific times
    if (milisec < 20000 && !balloons[0].hit)
        displayBalloon(balloons[0].x, balloons[0].y, balloons[0].color);
    if (milisec < 19400 && !balloons[1].hit)
        displayBalloon(balloons[1].x, balloons[1].y, balloons[1].color);
    if (milisec < 18800 && !balloons[2].hit)
        displayBalloon(balloons[2].x, balloons[2].y, balloons[2].color);
    if (milisec < 18200 && !balloons[3].hit)
        displayBalloon(balloons[3].x, balloons[3].y, balloons[3].color);
    if (milisec < 17600 && !balloons[4].hit)
        displayBalloon(balloons[4].x, balloons[4].y, balloons[4].color);

    displayBullet(bullet.x, bullet.y);

    displayGun(gunY);

    displayPanels();

    glutSwapBuffers();
}

//
// key function for ASCII charachters like ESC, a,b,c..,A,B,..Z
//
void onKeyDown(unsigned char key, int x, int y)
{
    // exit when ESC is pressed.
    if (key == 27)
        exit(0);

    // shoots the bullet
    if (key == ' ')
        bullet.shoot = true;

    // to refresh the window it calls display() function
    glutPostRedisplay();
}

void onKeyUp(unsigned char key, int x, int y)
{
    // exit when ESC is pressed.
    if (key == 27)
        exit(0);

    if (key == ' ')
        bullet.shoot = false;

    // to refresh the window it calls display() function
    glutPostRedisplay();
}

//
// Special Key like GLUT_KEY_F1, F2, F3,...
// Arrow Keys, GLUT_KEY_UP, GLUT_KEY_DOWN, GLUT_KEY_RIGHT, GLUT_KEY_RIGHT
//
void onSpecialKeyDown(int key, int x, int y)
{
    // Write your codes here.
    switch (key) {
    case GLUT_KEY_UP:
        up = true;
        break;
    case GLUT_KEY_DOWN:
        down = true;
        break;
    case GLUT_KEY_LEFT:
        left = true;
        break;
    case GLUT_KEY_RIGHT:
        right = true;
        break;
    case GLUT_KEY_F1:
        // first, resets necessary values. Then, changes the gamestate to run.
        // also pauses
        if (gameState == STATE_END)
        {
            for (int i = 0; i < 5; i++)
                balloons[i].y = -430;
            milisec = 20000;
            bullet.x = 700;
            gunY = 0;
            score = 0;
            newMax = 0;
            gameState = STATE_RUN;
        }
        else if (gameState == STATE_RUN)
            gameState = STATE_STOP;
        else if (gameState == STATE_STOP)
            gameState = STATE_RUN;
        break;
    }

    // to refresh the window it calls display() function
    glutPostRedisplay();
}

//
// Special Key like GLUT_KEY_F1, F2, F3,...
// Arrow Keys, GLUT_KEY_UP, GLUT_KEY_DOWN, GLUT_KEY_RIGHT, GLUT_KEY_RIGHT
//
void onSpecialKeyUp(int key, int x, int y)
{
    // Write your codes here.
    switch (key) {
    case GLUT_KEY_UP:
        up = false;
        break;
    case GLUT_KEY_DOWN:
        down = false;
        break;
    case GLUT_KEY_LEFT:
        left = false;
        break;
    case GLUT_KEY_RIGHT:
        right = false;
        break;
    case GLUT_KEY_F1:
        F1 = false;
        break;
    }

    // to refresh the window it calls display() function
    glutPostRedisplay();
}

//
// When a click occurs in the window,
// It provides which button
// buttons : GLUT_LEFT_BUTTON , GLUT_RIGHT_BUTTON
// states  : GLUT_UP , GLUT_DOWN
// x, y is the coordinate of the point that mouse clicked.
//
// GLUT to OpenGL coordinate conversion:
//   x2 = x1 - winWidth / 2
//   y2 = winHeight / 2 - y1
void onClick(int button, int stat, int x, int y)
{
    // Write your codes here.



    // to refresh the window it calls display() function
    glutPostRedisplay();
}

//
// This function is called when the window size changes.
// w : is the new width of the window in pixels.
// h : is the new height of the window in pixels.
//
void onResize(int w, int h)
{
    winWidth = w;
    winHeight = h;
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(-w / 2, w / 2, -h / 2, h / 2, -1, 1);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    display(); // refresh window.
}

void onMoveDown(int x, int y) {
    // Write your codes here.



    // to refresh the window it calls display() function   
    glutPostRedisplay();
}

// GLUT to OpenGL coordinate conversion:
//   x2 = x1 - winWidth / 2
//   y2 = winHeight / 2 - y1
void onMove(int x, int y) {
    // Write your codes here.



    // to refresh the window it calls display() function
    glutPostRedisplay();
}

#if TIMER_ON == 1
void onTimer(int v) {

    glutTimerFunc(TIMER_PERIOD, onTimer, 0);
    // Write your codes here.

    // if game is on run,
    if (gameState == STATE_RUN)
    {
        // update timer
        milisec -= TIMER_PERIOD;

        // if 20 sec ends, end the game
        if (milisec <= 0)
        {
            if (score > maxScore)
            {
                maxScore = score;
                newMax = true;
            }
            milisec = 0;
            gameState = STATE_END;
        }

        // if space is pressed, change its position to the gun's position
        if (bullet.shoot == true && bullet.x >= 500)
        {
            bullet.x = -400;
            bullet.y = gunY;
            bullet.shoot = false;
        }

        // if bullet is not above x = 500, hits the balloons and updates the score. Hitted balloons dissappear and go -90 at y axis.
        // Then, hitted balloons respawn if they are at y = 470.
        if (bullet.x < 500)
        {
            bullet.x += 30;
            //check if it hit a balloon
            for (int i = 0; i < 5; i++)
                if (bullet.x > balloons[i].x - 30 && bullet.x - 30 < balloons[i].x + 30 && bullet.y + 6 > balloons[i].y - 30 && bullet.y - 6 < balloons[i].y + 30)
                {
                    score++;
                    balloons[i].y = balloons[i].y - 90;
                    balloons[i].hit = 1;
                }
        }

        // change gun position
        if (gunY > -290)
            if (down)
                gunY -= 12;
        if (gunY < 350)
            if (up)
                gunY += 12;

        // starts to change the balloon positions at specific times.
        if (milisec < 20000)
            balloons[0].y += 9;
        if (milisec < 19400)
            balloons[1].y += 9;
        if (milisec < 18800)
            balloons[2].y += 9;
        if (milisec < 18200)
            balloons[3].y += 9;
        if (milisec < 17600)
            balloons[4].y += 9;

        // changes balloons' positions to y = -430 if their y = 470
        for (int i = 0; i < 5; i++)
            if (balloons[i].y == 470)
            {
                srand(milisec);
                balloons[i].y = -430;
                balloons[i].x = rand() % 360 - 30;
                balloons[i].color = rand() % 5;
                balloons[i].hit = 0;
            }
    }

    // to refresh the window it calls display() function
    glutPostRedisplay(); // display()

}
#endif

void Init() {

    // Smoothing shapes
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

    srand(time(NULL));

    // changes colors randomly and their x's at start.
    for (int i = 0; i < 5; i++)
    {
        balloons[i].x = rand() % 360 - 30;
        balloons[i].color = rand() % 5;
    }
}

void main(int argc, char* argv[]) {
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE);
    glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT);

    glutInitWindowPosition(0, 0);
    glutCreateWindow("SHOOT THE BALLOONS! - Baris Cihanoglu");

    glutDisplayFunc(display);
    glutReshapeFunc(onResize);

    //
    // keyboard registration
    //
    glutKeyboardFunc(onKeyDown);
    glutSpecialFunc(onSpecialKeyDown);

    glutKeyboardUpFunc(onKeyUp);
    glutSpecialUpFunc(onSpecialKeyUp);

    //
    // mouse registration
    //
    glutMouseFunc(onClick);
    glutMotionFunc(onMoveDown);
    glutPassiveMotionFunc(onMove);

#if  TIMER_ON == 1
    // timer event
    glutTimerFunc(TIMER_PERIOD, onTimer, 0);
#endif

    Init();

    glutMainLoop();
}
